using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;

namespace Gadgeteer.Modules.Gadgeteerin
{
    /// <summary>
    /// A IM_ServoTidy module for Microsoft .NET Gadgeteer
    /// </summary>
    public class IM_ServoTidy : Module
    {
        // This example implements a driver in managed code for a simple Gadgeteer module.  This module uses a 
        // single GTI.InterruptInput to interact with a button that can be in either of two states: pressed or released.
        // The example code shows the recommended code pattern for exposing a property (IsPressed). 
        // The example also uses the recommended code pattern for exposing two events: Pressed and Released. 
        // The triple-slash "///" comments shown will be used in the build process to create an XML file named
        // GTM.Gadgeteerin.IM_ServoTidy. This file will provide IntelliSense and documentation for the
        // interface and make it easier for developers to use the IM_ServoTidy module.        

        // -- CHANGE FOR MICRO FRAMEWORK 4.2 --
        // If you want to use Serial, SPI, or DaisyLink (which includes GTI.SoftwareI2C), you must do a few more steps
        // since these have been moved to separate assemblies for NETMF 4.2 (to reduce the minimum memory footprint of Gadgeteer)
        // 1) add a reference to the assembly (named Gadgeteer.[interfacename])
        // 2) in GadgeteerHardware.xml, uncomment the lines under <Assemblies> so that end user apps using this module also add a reference.

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public IM_ServoTidy(int socketNumber)
        {
            // This finds the Socket instance from the user-specified socket number.  
            // This will generate user-friendly error messages if the socket is invalid.
            // If there is more than one socket on this module, then instead of "null" for the last parameter, 
            // put text that identifies the socket to the user (e.g. "S" if there is a socket type S)
            var socket = Socket.GetSocket(socketNumber, true, this, null);

            // This creates an GTI.PWMOutput interface. The interfaces under the GTI namespace provide easy ways to build common modules.
            // This also generates user-friendly error messages automatically, e.g. if the user chooses a socket incompatible with an interrupt input.
            _pwmOutput = new GTI.PWMOutput(socket, Socket.Pin.Nine, false, this);

            IsReversed = false;
            MinAngle = -90;
            MaxAngle = 90;

            // Typical settings 
            MinUs = 1000;
            MaxUs = 2000;
        }

        private readonly GTI.PWMOutput _pwmOutput;

        /// <summary>
        /// Minimum timing of the pulse in microseconds. This value should not be changed unless you have a strange servo or wish to overdrive one (possibly damaging it)
        /// </summary>
        public int MinUs;
        /// <summary>
        /// Maximum timing of the pulse in microseconds. This value should not be changed unless you have a strange servo or wish to overdrive one (possibly damaging it)
        /// </summary>
        public int MaxUs;

        /// <summary>
        /// The minimum angle, assuming 0 is center, the servo is capable of travelling.
        /// </summary>
        /// <remarks>If the servo can travel 180 degrees, and 0 is centre, this would be -90.</remarks>
        public float MinAngle;
        /// <summary>
        /// The maximum angle, assuming 0 is center, the servo is capable of travelling.
        /// </summary>
        /// <remarks>If the servo can travel 180 degrees, and 0 is centre, this would be 90.</remarks>
        public float MaxAngle;

        /// <summary>
        /// If the servo should work in the opposite direction to normal.
        /// </summary>
        public bool IsReversed;

        /// <summary>
        /// Stop driving the servo by not sending it any control information. This should cause the servo to stop holding position and use less power
        /// </summary>
        public void Stop()
        {
            _pwmOutput.Set(0, 100);
        }

        /// <summary>
        /// Move the servo to a percentage of it's travel, where 50 would be centered, 0/100 as maximums for each direction.
        /// </summary>
        /// <param name="percent">Angle to move the servo to. Has a valid range of 0-100.</param>
        public void MovePercent(float percent)
        {
            if (percent < 0)
                percent = 0;

            if (percent > 100)
                percent = 100;

            float range = MaxAngle - MinAngle;

            // Position the servo 
            _pwmOutput.SetPulse(20000000, (uint)(((range * percent / 100) - MinAngle) * (MaxUs - MinUs) / (MaxAngle - MinAngle) + MinUs) * 1000);
        }

        /// <summary>
        /// Move the servo to the specified angle.
        /// </summary>
        /// <param name="angle">Angle to move to.</param>
        /// <remarks>This may not move the servo to this exact angle, depending on your servo's specifications.</remarks>
        public void Move(float angle)
        {
            // Data sanity check
            if (angle > MaxAngle)
                angle = MaxAngle;

            if (angle < MinAngle)
                angle = MinAngle;

            // Invert servo position if required
            if (IsReversed)
                angle = -angle;

            // Position the servo
            _pwmOutput.SetPulse(20000000, (uint)((angle - MinAngle) * (MaxUs - MinUs) / (MaxAngle - MinAngle) + MinUs) * 1000);
        }
    }
}
